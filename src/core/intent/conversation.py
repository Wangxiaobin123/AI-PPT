"""Multi-turn conversation management.

Tracks per-session conversation history, accumulated intent / parameter
state, and generates clarification questions when essential information is
missing from the user's request.
"""

from __future__ import annotations

import uuid

from pydantic import BaseModel, Field

from src.core.intent.prompts.clarification import (
    CLARIFICATION_SYSTEM_PROMPT,
    CLARIFICATION_USER_TEMPLATE,
)
from src.utils.logging import get_logger

logger = get_logger("intent.conversation")


# ---------------------------------------------------------------------------
# Data models
# ---------------------------------------------------------------------------


class ConversationContext(BaseModel):
    """State for a single conversation session.

    Attributes:
        session_id: Unique session identifier.
        history: Chronological list of ``{"role": ..., "content": ...}`` turns.
        current_intent: The most recently classified intent type (if any).
        current_params: Accumulated extraction parameters (dict form).
    """

    session_id: str = Field(default_factory=lambda: uuid.uuid4().hex[:12])
    history: list[dict] = []
    current_intent: str | None = None
    current_params: dict = {}


class ClarificationResponse(BaseModel):
    """Returned when the system needs more information from the user.

    Attributes:
        question: A user-facing follow-up question.
        missing_fields: The parameter names that still need values.
    """

    question: str
    missing_fields: list[str]


# ---------------------------------------------------------------------------
# Required fields per intent type
# ---------------------------------------------------------------------------

_REQUIRED_FIELDS: dict[str, list[str]] = {
    "create_pptx": ["output_format", "title"],
    "create_docx": ["output_format", "title"],
    "create_xlsx": ["output_format"],
    "create_pdf": ["output_format", "title"],
    "create_html": ["output_format", "title"],
    "convert": ["output_format"],
    "edit": [],
    "batch": [],
    "unknown": [],
}

_FIELD_DESCRIPTIONS: dict[str, str] = {
    "output_format": "the desired output file format",
    "title": "a title or topic for the content",
    "content": "the content to include",
    "slide_count": "how many slides to create",
}


# ---------------------------------------------------------------------------
# Conversation manager
# ---------------------------------------------------------------------------


class ConversationManager:
    """Manages multi-turn conversation state and clarification logic.

    Parameters
    ----------
    llm_client:
        Optional :class:`~src.core.llm.client.LLMClient`.  When provided,
        clarification questions are generated by the model; otherwise a
        template-based question is produced.
    """

    def __init__(self, llm_client=None):
        self.sessions: dict[str, ConversationContext] = {}
        self.llm = llm_client

    def get_or_create_session(self, session_id: str) -> ConversationContext:
        """Return the context for *session_id*, creating it if needed."""
        if session_id not in self.sessions:
            self.sessions[session_id] = ConversationContext(session_id=session_id)
            logger.info("session_created", session_id=session_id)
        return self.sessions[session_id]

    def update_context(
        self,
        session_id: str,
        role: str,
        content: str,
    ) -> None:
        """Append a message to the session's history."""
        ctx = self.get_or_create_session(session_id)
        ctx.history.append({"role": role, "content": content})

    def set_intent(self, session_id: str, intent_type: str) -> None:
        """Record the current intent for the session."""
        ctx = self.get_or_create_session(session_id)
        ctx.current_intent = intent_type

    def merge_params(self, session_id: str, params: dict) -> None:
        """Merge newly extracted parameters into the session's accumulated params.

        Only non-``None`` values overwrite existing ones so that subsequent
        user messages refine rather than erase earlier extraction results.
        """
        ctx = self.get_or_create_session(session_id)
        for key, value in params.items():
            if value is not None:
                ctx.current_params[key] = value

    # ----- Clarification logic ----------------------------------------------

    async def needs_clarification(
        self,
        intent_type: str,
        params,
    ) -> bool:
        """Return ``True`` when essential parameters are still missing."""
        missing = self._find_missing_fields(intent_type, params)
        return len(missing) > 0

    async def generate_clarification(
        self,
        intent_type: str,
        params,
        user_input: str = "",
    ) -> ClarificationResponse:
        """Produce a :class:`ClarificationResponse` listing the missing fields.

        If an LLM is available the question is generated by the model;
        otherwise a simple template is used.
        """
        missing = self._find_missing_fields(intent_type, params)

        if self.llm is not None:
            try:
                question = await self._llm_clarification(
                    intent_type, params, missing, user_input,
                )
                return ClarificationResponse(
                    question=question,
                    missing_fields=missing,
                )
            except Exception as exc:
                logger.warning(
                    "llm_clarification_failed_falling_back",
                    error=str(exc),
                )

        question = self._template_clarification(missing)
        return ClarificationResponse(question=question, missing_fields=missing)

    # ----- Internal helpers -------------------------------------------------

    @staticmethod
    def _find_missing_fields(intent_type: str, params) -> list[str]:
        """Determine which required fields are absent or empty."""
        required = _REQUIRED_FIELDS.get(intent_type, [])
        if not required:
            return []

        # Accept both a dict and a Pydantic model.
        if hasattr(params, "model_dump"):
            param_dict = params.model_dump()
        elif isinstance(params, dict):
            param_dict = params
        else:
            param_dict = {}

        missing: list[str] = []
        for field in required:
            value = param_dict.get(field)
            if value is None or value == "":
                missing.append(field)
        return missing

    async def _llm_clarification(
        self,
        intent_type: str,
        params,
        missing: list[str],
        user_input: str,
    ) -> str:
        """Generate a clarification question using the LLM."""
        descriptions = [
            _FIELD_DESCRIPTIONS.get(f, f) for f in missing
        ]
        system = CLARIFICATION_SYSTEM_PROMPT.format(
            missing_fields=", ".join(descriptions),
        )
        if hasattr(params, "model_dump"):
            params_str = str(params.model_dump(exclude_none=True))
        else:
            params_str = str(params)

        user_msg = CLARIFICATION_USER_TEMPLATE.format(
            intent_type=intent_type,
            current_params=params_str,
            user_input=user_input,
        )
        return await self.llm.complete(system, user_msg)

    @staticmethod
    def _template_clarification(missing: list[str]) -> str:
        """Generate a clarification question without the LLM."""
        descriptions = [
            _FIELD_DESCRIPTIONS.get(f, f) for f in missing
        ]
        if len(descriptions) == 1:
            return f"Could you please provide {descriptions[0]}?"
        joined = ", ".join(descriptions[:-1]) + f" and {descriptions[-1]}"
        return f"Could you please provide {joined}?"
